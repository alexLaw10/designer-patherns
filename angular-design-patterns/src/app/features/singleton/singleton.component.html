<div class="singleton-demo demo-container">
  <div class="demo-header">
    <h2>üîí Singleton Pattern</h2>
    <p>O Singleton Pattern garante que uma classe tenha apenas uma inst√¢ncia e fornece um ponto global de acesso a ela.</p>
  </div>
  
  <div class="demo-content">
    <div class="instance-info demo-section">
      <h3>üè∑Ô∏è Informa√ß√µes da Inst√¢ncia</h3>
      <div class="info-card">
        <div class="info-item">
          <span class="info-label">ID da Inst√¢ncia:</span>
          <span class="info-value">{{ instanceId }}</span>
        </div>
        <div class="info-item">
          <span class="info-label">Total de Logs:</span>
          <span class="info-value">{{ totalLogs }}</span>
        </div>
        <div class="info-item">
          <span class="info-label">Status:</span>
          <span class="info-value status-active">Ativo</span>
        </div>
      </div>
    </div>
    
    <div class="log-creator demo-section">
      <h3>üìù Criar Log</h3>
      <div class="form-grid two-columns">
        <div class="form-group">
          <label>N√≠vel do Log:</label>
          <select [(ngModel)]="selectedLevel" class="form-select">
            <option *ngFor="let level of getLogLevels()" [value]="level">
              {{ getLogLevelIcon(level) }} {{ getLogLevelName(level) }}
            </option>
          </select>
        </div>
        
        <div class="form-group">
          <label>Fonte (opcional):</label>
          <input type="text" [(ngModel)]="newSource" placeholder="Ex: AuthService" class="form-input">
        </div>
        
        <div class="form-group full-width">
          <label>Mensagem:</label>
          <input type="text" [(ngModel)]="newMessage" placeholder="Digite sua mensagem..." class="form-input" (keyup.enter)="addLog()">
        </div>
      </div>
      
      <div class="form-actions btn-group">
        <button (click)="addLog()" class="btn btn-primary" [disabled]="!newMessage.trim()">
          ‚ûï Adicionar Log
        </button>
        <button (click)="addSampleLogs()" class="btn btn-secondary">
          üéØ Logs de Exemplo
        </button>
        <button (click)="addRandomLog()" class="btn btn-info">
          üé≤ Log Aleat√≥rio
        </button>
      </div>
    </div>
    
    <div class="logs-section demo-section">
      <h3>üìã Logs Registrados</h3>
      <div class="logs-controls btn-group">
        <button (click)="clearLogs()" class="btn btn-danger">
          üóëÔ∏è Limpar Logs
        </button>
        <button (click)="exportLogs()" class="btn btn-success">
          üíæ Exportar JSON
        </button>
      </div>
      
      <div class="logs-stats stats-grid auto-fit-120">
        <div class="stat-item" *ngFor="let level of getLogLevels()">
          <span class="stat-icon">{{ getLogLevelIcon(level) }}</span>
          <span class="stat-label">{{ getLogLevelName(level) }}:</span>
          <span class="stat-value">{{ logsByLevel[level] }}</span>
        </div>
      </div>
      
      <div class="logs-list scrollable-list">
        <div *ngFor="let log of logs; let i = index" 
             class="log-item" 
             [style.border-left-color]="getLogLevelColor(log.level)">
          <div class="log-header">
            <span class="log-icon">{{ getLogLevelIcon(log.level) }}</span>
            <span class="log-level">{{ getLogLevelName(log.level) }}</span>
            <span class="log-time">{{ log.timestamp | date:'HH:mm:ss' }}</span>
            <span class="log-source" *ngIf="log.source">{{ log.source }}</span>
          </div>
          <div class="log-message">{{ log.message }}</div>
          <div class="log-data" *ngIf="log.data">
            <pre>{{ log.data | json }}</pre>
          </div>
        </div>
        
        <div *ngIf="logs.length === 0" class="empty-logs empty-state large">
          <span class="empty-icon">üìù</span>
          <p>Nenhum log registrado ainda</p>
          <small>Crie um log usando o formul√°rio acima</small>
        </div>
      </div>
    </div>
  </div>
  
  <div class="explanation">
    <h3>üîç Singleton Pattern - Conceito e Implementa√ß√£o</h3>
    <div class="explanation-content">
      
      <div class="concept content-card">
        <h4>üìö Conceito</h4>
        <p>O Singleton Pattern √© um padr√£o criacional que garante que uma classe tenha apenas uma inst√¢ncia e fornece um ponto global de acesso a essa inst√¢ncia. No Angular, os servi√ßos com <code class="inline-code">providedIn: 'root'</code> s√£o singletons por padr√£o.</p>
        <p><strong>Problema que resolve:</strong> Como garantir que uma classe tenha apenas uma inst√¢ncia? Como fornecer acesso global a essa inst√¢ncia?</p>
      </div>
      
      <div class="flow content-card">
        <h4>üîÑ Fluxo de Funcionamento</h4>
        <div class="flow-steps">
          <div class="flow-step">
            <div class="step-number">1</div>
            <div class="step-content">
              <strong>Primeira solicita√ß√£o</strong>
              <p>Quando o Singleton √© solicitado pela primeira vez, uma nova inst√¢ncia √© criada.</p>
            </div>
          </div>
          <div class="flow-step">
            <div class="step-number">2</div>
            <div class="step-content">
              <strong>Inst√¢ncia armazenada</strong>
              <p>A inst√¢ncia criada √© armazenada em uma vari√°vel est√°tica da classe.</p>
            </div>
          </div>
          <div class="flow-step">
            <div class="step-number">3</div>
            <div class="step-content">
              <strong>Pr√≥ximas solicita√ß√µes</strong>
              <p>Nas pr√≥ximas solicita√ß√µes, a mesma inst√¢ncia √© retornada.</p>
            </div>
          </div>
          <div class="flow-step">
            <div class="step-number">4</div>
            <div class="step-content">
              <strong>Estado compartilhado</strong>
              <p>Todos os consumidores compartilham o mesmo estado da inst√¢ncia.</p>
            </div>
          </div>
        </div>
      </div>
      
      <div class="angular-specific content-card">
        <h4>üÖ∞Ô∏è Como Funciona no Angular</h4>
        <p>No Angular, o Singleton Pattern √© implementado automaticamente:</p>
        <ul>
          <li><strong>Servi√ßos com providedIn: 'root':</strong> Uma √∫nica inst√¢ncia para toda a aplica√ß√£o</li>
          <li><strong>Dependency Injection:</strong> O Angular gerencia a cria√ß√£o e reutiliza√ß√£o de inst√¢ncias</li>
          <li><strong>Shared State:</strong> Estado compartilhado entre componentes</li>
          <li><strong>Memory Efficiency:</strong> Evita cria√ß√£o desnecess√°ria de m√∫ltiplas inst√¢ncias</li>
        </ul>
      </div>
      
      <div class="code-example content-card">
        <h4>üíª C√≥digo do Exemplo</h4>
        <div class="code-block">
          <div class="code-header">
            <div class="traffic-lights">
              <div class="traffic-light close"></div>
              <div class="traffic-light minimize"></div>
              <div class="traffic-light maximize"></div>
            </div>
            <div class="code-title">logger.service.ts</div>
          </div>
          <pre><code>// Interface do Logger
export interface Logger &#123;
  log(level: LogLevel, message: string, source?: string, data?: any): void;
  getLogs(): LogEntry[];
  clearLogs(): void;
&#125;

// Enum para n√≠veis de log
export enum LogLevel &#123;
  INFO = 'info',
  WARN = 'warn',
  ERROR = 'error',
  DEBUG = 'debug'
&#125;

// Interface para entrada de log
export interface LogEntry &#123;
  id: string;
  level: LogLevel;
  message: string;
  timestamp: Date;
  source?: string;
  data?: any;
&#125;

// Singleton Service
@Injectable(&#123;
  providedIn: 'root' // Garante que seja singleton
&#125;)
export class LoggerService implements Logger &#123;
  private static instance: LoggerService;
  private logs: LogEntry[] = [];
  private instanceId: string;

  constructor() &#123;
    if (LoggerService.instance) &#123;
      return LoggerService.instance;
    &#125;
    
    this.instanceId = this.generateId();
    LoggerService.instance = this;
  &#125;

  log(level: LogLevel, message: string, source?: string, data?: any): void &#123;
    const logEntry: LogEntry = &#123;
      id: this.generateId(),
      level,
      message,
      timestamp: new Date(),
      source,
      data
    &#125;;
    
    this.logs.push(logEntry);
    console.log('[' + level.toUpperCase() + '] ' + 
               (source ? '[' + source + '] ' : '') + message, data || '');
  &#125;

  getLogs(): LogEntry[] &#123;
    return [...this.logs];
  &#125;

  clearLogs(): void &#123;
    this.logs = [];
  &#125;

  private generateId(): string &#123;
    return Math.random().toString(36).substr(2, 9);
  &#125;
&#125;</code></pre>
        </div>
      </div>
      
    </div>
  </div>
</div>